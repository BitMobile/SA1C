
#Region CommonProcedureAndFunctions

&AtServer
Procedure OnCreateAtServer(Cancel, StandardProcessing)
	
	PredefinedItems = New Map;
	PredefinedItems.Insert("Catalog.Brands", "Brand");
	PredefinedItems.Insert("Catalog.UnitsOfMeasure", "BaseUnit");
	PredefinedItems.Insert("Catalog.SKUGroup", "Owner");
	
	ItemsCollection = CommonProcessors.GetPredefinedItems(PredefinedItems);
	
	For Each Item In ItemsCollection Do
		
		Object[Item.Key] = Item.Value;

	EndDo;
	
	CheckBaseUnitAndMultiplier();
	
	Query = New Query;
	Query.Text = 
		"SELECT ALLOWED TOP 1
		|	StorageAdditionalInformation.Object,
		|	StorageAdditionalInformation.SyncDirection,
		|	StorageAdditionalInformation.Action,
		|	StorageAdditionalInformation.User,
		|	StorageAdditionalInformation.FileName,
		|	StorageAdditionalInformation.FullFileName,
		|	StorageAdditionalInformation.Extension,
		|	StorageAdditionalInformation.Storage
		|FROM
		|	InformationRegister.StorageAdditionalInformation AS StorageAdditionalInformation
		|WHERE
		|	StorageAdditionalInformation.Object = &ObjectRef
		|	AND StorageAdditionalInformation.Action <> &DeleteAction
		|	AND StorageAdditionalInformation.FileName = &FileName
		|	AND StorageAdditionalInformation.SyncDirection = &SyncDirection";

	Query.SetParameter("DeleteAction", Enums.SyncAction.DeleteFile);
	Query.SetParameter("SyncDirection", Enums.SyncDirections.Shared);
	Query.SetParameter("ObjectRef", Object.Ref);
	Query.SetParameter("FileName", Object.DefaultPicture);
	
	Result = Query.Execute();

	Records = Result.Select();

	If Records.Next() Then 
		
		PictureAddress = PutToTempStorage(Records.Storage.Get(), ThisForm.UUID);
						
	EndIf;	
	
	DefaultPictureName = Object.DefaultPicture;
	DefaultPictureExtension = Object.DefaultPictureExtension;
		
EndProcedure

&AtServer
Procedure BeforeWriteAtServer(Cancel, CurrentObject, WriteParameters)
	
	If Not ValueIsFilled(Object.DefaultPicture) Then
		
		If ValueIsFilled(NewPictureName) Then
			
			CurrentObject.DefaultPicture = NewPictureName;
			CurrentObject.DefaultPictureExtension = NewPictureExtension;
			
		EndIf;
		
	EndIf;
	
EndProcedure

&AtServer
Procedure OnWriteAtServer(Cancel, CurrentObject, WriteParameters)
	
	If Not Cancel Then 
	
		If CurrentObject.DefaultPicture = NewPictureName And ValueIsFilled(NewPictureName) Then 
			
			If NewPictureType = "New" Then 
				
				
				TempFile 	= GetTempFileName(NewPictureExtension);
				BinaryData	= GetFromTempStorage(PictureAddress);
				BinaryData.Write(TempFile);
				
				CheckFileSize = New File(TempFile);
				
				RecordManager 				= InformationRegisters.StorageAdditionalInformation.CreateRecordManager();
				RecordManager.Object 		= CurrentObject.Ref;
				RecordManager.SyncDirection = Enums.SyncDirections.Shared;
				RecordManager.Action 		= Enums.SyncAction.AddFile;
				RecordManager.FileName 		= NewPictureName;
				RecordManager.Extension 	= Lower(NewPictureExtension);
				RecordManager.Storage 		= New ValueStorage(BinaryData);
				RecordManager.Size			= CheckFileSize.Size();
				RecordManager.FullFileName 	= "/shared/Catalog.SKU/" + CurrentObject.Ref.UUID() + "/" + NewPictureName + Lower(NewPictureExtension);
							
				RecordManager.Write();
				
			ElsIf NewPictureType = "Private" Then 
				
				SelectionStructure = New Structure("FileName");
				SelectionStructure.FileName = New UUID(NewPictureName);
				
				Selection = InformationRegisters.StorageAdditionalInformation.Select(SelectionStructure);
				
				If Selection.Next() Then 
					
					RecordManagerPrivate 				= InformationRegisters.StorageAdditionalInformation.CreateRecordManager();
				
				    FillPropertyValues(RecordManagerPrivate, Selection);
					
					RecordManagerPrivate.Read();
					
					TempFile 	= GetTempFileName(NewPictureExtension);
					BinaryData	= GetFromTempStorage(PictureAddress);
					BinaryData.Write(TempFile);
					
					CheckFileSize = New File(TempFile);
					
					RecordManagerPrivate.SyncDirection 	= Enums.SyncDirections.Shared;
					RecordManagerPrivate.Action 		= Enums.SyncAction.AddFile;
					RecordManagerPrivate.User			= Catalogs.User.EmptyRef();
					RecordManagerPrivate.Storage 		= New ValueStorage(BinaryData);
					RecordManagerPrivate.Size			= CheckFileSize.Size();
					RecordManagerPrivate.FullFileName 	= "/shared/Catalog.SKU/" + CurrentObject.Ref.UUID() + "/" + NewPictureName + Lower(NewPictureExtension);
								
					RecordManagerPrivate.Write();
					
				EndIf;
												
			EndIf;
														
		EndIf;
		
	EndIf;
		
EndProcedure

&AtServer
Procedure CheckBaseUnitAndMultiplier()
	
	If ValueIsFilled(Object.BaseUnit) Then 
	
		ParameterFilter = new Structure;
		ParameterFilter.Insert("Pack", Object.BaseUnit);
		
		FoundRow = Object.Packing.FindRows(ParameterFilter);
		
		If FoundRow.Count() = 0 Then
			
			NewRow				= Object.Packing.Add();
			NewRow.Pack			= Object.BaseUnit;
			NewRow.Multiplier	= 1;
			
			UserMessage			= New UserMessage;
			UserMessage.Text	= NStr("en = ""Warning, new base unit has multiplier 1. Check multipliers corectness, please.""; ru = ""Внимание, новая базовая единица имеет коэффициент 1. Проверьте, пожалуйста, коэффициенты на правильность.""");
			
			UserMessage.Message();
			
		Else
			
			If Not FoundRow[0].Multiplier = 1 Then 
				
				FoundRow[0].Multiplier = 1;
				
				UserMessage			= New UserMessage;
				UserMessage.Text	= NStr("en = ""Warning, new base unit has multiplier 1. Check multipliers corectness, please.""; ru = ""Внимание, новая базовая единица имеет коэффициент 1. Проверьте, пожалуйста, коэффициенты на правильность.""");
				
				UserMessage.Message();
				
			EndIf;
			
		EndIf;
		
	EndIf;
	
EndProcedure

&AtServer
Function GetConstant()
	Return Constants.SKUFeaturesRegistration.Get();
EndFunction // ()

&AtServer
Function ChangePackAvailable(mPack)
	
	If ValueIsFilled(Object.Ref) Then 
		
		Query = New Query;
		Query.Text = 
			"SELECT
			|	AssortmentMatrixSKUs.AssortmentMatrix AS AM,
			|	AssortmentMatrixSKUs.AssortmentMatrix.Code AS Code
			|FROM
			|	InformationRegister.AssortmentMatrixSKUs AS AssortmentMatrixSKUs
			|WHERE
			|	AssortmentMatrixSKUs.SKU = &SKU
			|	AND AssortmentMatrixSKUs.Unit = &Pack
			|
			|GROUP BY
			|	AssortmentMatrixSKUs.AssortmentMatrix,
			|	AssortmentMatrixSKUs.AssortmentMatrix.Code";
		
		Query.SetParameter("SKU", Object.Ref);
		Query.SetParameter("Pack", mPack);
		
		QueryResult = Query.Execute();
		
		Selection = QueryResult.Select();
		
		ReturnResult = True;
		
		While Selection.Next() Do
			
			ReturnResult = False;
			
			UserMessage			= New UserMessage;
			UserMessage.Text	= NStr("en = 'SKU and Packing used in the assortment matrix " + String(Selection.Code) + " - """ + String(Selection.AM) + """.'; ru = 'Номенклатура и упаковка используются в ассортиментной матрице " + String(Selection.Code) + " - """ + String(Selection.AM) + """.'");
			
			UserMessage.Message();
			
		EndDo;
		
		If Not ReturnResult Then 
			
			UserMessage			= New UserMessage;
			UserMessage.Text	= NStr("en = 'Change prohibited.'; ru = 'Изменение запрещено.'");
			
			UserMessage.Message();
			
		EndIf;
		
		Return ReturnResult;
		
	Else 
		
		Return True;
		
	EndIf;
	
EndFunction

#EndRegion

#Region UserInterface

&AtClient
Procedure OnOpen(Cancel)
	
	Items.Stock.ReadOnly = GetConstant();
	
EndProcedure

&AtClient
Procedure BaseUnitOnChange(Item)
	
	CheckBaseUnitAndMultiplier();
	
EndProcedure

&AtClient
Procedure PackingBeforeDeleteRow(Item, Cancel)
	
	If Not Items.Packing.CurrentData = Undefined Then 
		
		Cancel = Not ChangePackAvailable(Items.Packing.CurrentData.Pack);
		
	EndIf;
	
EndProcedure

&AtClient
Procedure PackingBeforeRowChange(Item, Cancel)
	
	If Item.CurrentItem = Items.PackingPack Then 
	
		If Not Items.Packing.CurrentData = Undefined Then 
			
			Cancel = Not ChangePackAvailable(Items.Packing.CurrentData.Pack);
			
		EndIf;
		
	EndIf;
	
EndProcedure

#Region Pictures

&AtClient
Procedure EditPicture(Command)
	
	SelectPicture();
	
EndProcedure

&AtClient
Procedure DeletePicture(Command)
	
	NewPictureName 		= Undefined;
	NewPictureExtension = Undefined;
	
	Object.DefaultPicture 			= Undefined;
	Object.DefaultPictureExtension 	= Undefined;
	
	PictureAddress = "";
	
	Modified = True;
	
EndProcedure

&AtClient
Procedure OpenPicture(Command)
	
	FileName = Undefined;
	
	If ValueIsFilled(Object.DefaultPicture) Then 
		
		FileName = String(Object.DefaultPicture) + Object.DefaultPictureExtension;
		
	ElsIf ValueIsFilled(NewPictureName) Then 
		
		FileName = String(NewPictureName) + NewPictureExtension;
		
	EndIf;
		
	If ValueIsFilled(FileName) Then 
		
		GetFile(PictureAddress, FileName, True);
		
	EndIf;
		
EndProcedure

&AtClient
Procedure PictureAddressClick(Item, StandardProcessing)
	
	StandardProcessing = False;
	
	SelectPicture();
				
EndProcedure

&AtClient
Procedure SelectPicture()
	
	OpenForm("CommonForm.PickPictureFromForm", , ThisForm, , , , New NotifyDescription("SelectPictureProcessing", ThisForm));
	
EndProcedure

&AtClient
Procedure SelectPictureProcessing(Result, AdditionalParameter) Export 
	
	If Not Result = Undefined Then
		
		ThisForm.PictureAddress			= Result.StorageAddress;
		ThisForm.NewPictureName			= Result.FileName;
		ThisForm.NewPictureExtension	= Result.Extension;
		ThisForm.NewPictureType			= Result.Type;
		
		Object.DefaultPicture			= Undefined;
		Object.DefaultPictureExtension	= Undefined;
		
		Items.PictureAddress.Refresh();
		
		Modified = True;
		
	EndIf;
	
EndProcedure

#EndRegion

#EndRegion
